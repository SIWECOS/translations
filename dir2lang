#!/usr/bin/perl
=head1 NAME

dir2lang - Convert SIWECOS translations to be used by the application

=head1 SYNOPSIS

B<dir2lang> [B<-v>] [B<--dryrun>]

B<dir2wiki> B<--help>|B<--man>

=head1 Description

dir2lang will take all SIWECOS translations found and copy them into PHP files.

=cut
use strict;
use warnings;
use FindBin qw($Bin $Script);
use Getopt::Long qw(:config no_ignore_case);
use Pod::Usage;
use lib "$Bin/lib";
use MediaWiki::API;
use Config::Simplest;
use File::Basename;
use utf8;

my $EXT='.wiki';
my $SCANNER_NAME= 'SCANNER_NAME';
my $RESULTS= 'RESULTS';
$|= 1;

binmode(STDOUT, ":utf8");
my $settings= get_config("$Bin/wiki.conf", qw(WIKI API));
my $config= get_config("$Bin/siwecos.conf");

=head1 options

=over 4

=cut

my $dryrun = 0;
=item B<--dryrun>

=item B<-d>

Just test the translations.

=cut

my $test = '';
=item B<--test> DIRNAME

=item B<-t> DIRNAME

Like B<--dryrun> but create the files in DIRNAME.

=cut

my $verbose= 0;

=item B<-v>

Verbose output.

=cut

help() unless GetOptions(
    'v+'         => \$verbose,
    'dryrun'     => \$dryrun,
    'test=s'     => \$test,
    'h|help'     => \&help,
    'm|man'      => \&man,
);

=item B<--help>

short help page

=item B<--man>

show man page

=back

=cut

sub help { pod2usage(-verbose=>1); }
sub man  { pod2usage(-verbose=>2); }

# Location and names of some directories / files
# $Bin = absolute path of this script
# $Script = filename of this script
my $TRANSLATIONS= "$Bin/texts";
my $LANGUAGE_DIR=  $config->{LANGUAGE_DIR}       || "$Bin/lang";
my $WIKI_LINK=     $config->{TARGET_WIKI_LINK}   || "siwecos_wiki";
my $WIKI_EXTERN=   $config->{TARGET_EXTERN_LINK} || "siwecos_extern";
my $TEMPLATEFILE= "$Bin/$Script.txt";

# Expected purposes
my $CATEGORY     = 'Category';
my $DESCRIPTION  = 'Description';
my $HEADLINE     = 'Headline';
my $LINK         = 'Link';
my $ERROR_TEXT   = 'Negative';
my $SUCCESS_TEXT = 'Positive';
my $TIPP         = 'Solution_Tips';

my %PREPARE = (
    $CATEGORY     => \&oneline,
    $DESCRIPTION  => \&parse_wiki,
    $HEADLINE     => \&oneline_wiki,
    $LINK         => \&wikilink,
    $ERROR_TEXT   => \&oneline_wiki,
    $SUCCESS_TEXT => \&oneline_wiki,
    $TIPP         => \&parse_wiki,
);
my @PURPOSES= sort keys %PREPARE;
# Prepare some output stuff
# Sequence of textnames in output
my @SEQUENCE = (
    $HEADLINE,
    $SUCCESS_TEXT,
    $ERROR_TEXT,
    $DESCRIPTION,
    $TIPP,
    $LINK,
);
my $fill= maxlen( @SEQUENCE);   # number of spaces to use to align values vertically

# First prepare the template
open my $template, '<', $TEMPLATEFILE
    or die "Cannot read template $TEMPLATEFILE: $!\n";
my @template= <$template>;
close $template;

die "Cannot access directory $TRANSLATIONS\n"
    unless -x $TRANSLATIONS and -r $TRANSLATIONS;

my $lang_dir= $test || $LANGUAGE_DIR;
if ( not -d $lang_dir ) {
    mkdir $lang_dir
        or die "Can't create $lang_dir: $!\n";
}
die "Can't write to $lang_dir.\n"
    unless -w $lang_dir;

my %LANGUAGES;
my %test_translations;
my %translations;
my $warning;
my $count= 0;
foreach my $dir (glob("$TRANSLATIONS/*")) {
    my $scanner= basename $dir;
    print "\r$scanner\n" if $verbose;
    foreach my $dir (glob("$dir/*")) {
        my $test= basename $dir;
        print "\r  $test\n" if $verbose;
        # Special cases _$RESULTS an _$SCANNER_NAME
        if ($test=~ /^_/) {
            #
            # _$SCANNER_NAME
            #
            if ($test eq "_$SCANNER_NAME") {
                my $text= read_text($dir);
                if (ref $text) {
                    $translations{$scanner}{$SCANNER_NAME}= $text;
                    ++$count;
                } else {
                    ++$warning;
                    warn "$text\n";
                }
            #
            # _$RESULTS
            #
            } else {
                foreach my $dir (glob("$dir/*")) {
                    my $textname= basename $dir;
                    my $text= read_text($dir);
                    if (ref $text) {
                        $translations{$scanner}{$textname}= $text;
                        ++$count;
                    } else {
                        ++$warning;
                        warn "$text\n";
                    }
                }
            }
        } else {
            #
            # TESTS
            #
            while (my($purpose, $prepare)= each %PREPARE) {
                my $text= read_text("$dir/$purpose");
                if (ref $text) {
                    $test_translations{$scanner}{$test}{$purpose}= $text;
                    ++$count;
                } else {
                    ++$warning;
                    warn "$text\n";
                }
            }
        }
    }
}
my @LANGUAGES= sort keys %LANGUAGES;

die "Too many errors.\n" if $warning;

# Check missing translations
my @scanners= sort keys %test_translations, keys %translations;
foreach my $scanner (@scanners) {
    # Data structure is
    # test_translations {scanner} -> {test} -> {purpose} -> {language}
    foreach my $test (sort keys %{$test_translations{$scanner}}) {
        foreach my $purpose (@PURPOSES) {
            foreach my $lang (@LANGUAGES) {
                next if exists $test_translations{$scanner}{$test}{$purpose}{$lang};
                ++$warning;
                warn "No $lang translation for $scanner/$test/$purpose\n";
            }
        }
    }
    # Data structure is
    # translations {scanner} -> {textname} -> {language}
    foreach my $textname (sort keys %{$translations{$scanner}}) {
        foreach my $lang (@LANGUAGES) {
            next if exists $translations{$scanner}{$textname}{$lang};
            ++$warning;
            if ($textname eq $SCANNER_NAME) {
                warn "No $lang translation for $scanner/_$SCANNER_NAME\n";
            } else {
                warn "No $lang translation for $scanner/_$RESULTS/$textname\n";
            }
        }
    }
}

die "Too many errors.\n" if $warning;

# We need to use the wiki now
my $mw = MediaWiki::API->new({
    api_url => $settings->{API},
});

my $done= 0;
my $standard_prepare= $PREPARE{$HEADLINE};
foreach my $scanner (@scanners) {
    foreach my $lang (@LANGUAGES) {
        print "\rScanner $scanner, $lang\n" if $verbose;
        my $output= '';
        # go through the template, line by line
        foreach (@template) {
            # Until the placeholder /* DATA HERE */ is found
            if( m#^(\s*)/\*\s*DATA\s*HERE\s*\*/\s*#)  {
                # Remember the indent
                my $indent= $1;
                # SCANNER_NAME COMES FIRST!
                my $textname= $SCANNER_NAME;
                my $text= $translations{$scanner}{$textname}{$lang};
                if (defined $text) {
                    update_percent(\$done,$count);
                    $output.= "$indent// These are the $lang texts for\n";
                    if( $standard_prepare ){
                        $text= $standard_prepare->($mw, $text, $textname, undef, $lang);
                    }
                    $output.= qq:$indent'$textname' => "$text",\n\n:;
                    # Data structure is
                    # test_translations {scanner} -> {test} -> {purpose} -> {language}
                    foreach my $test (sort keys %{$test_translations{$scanner}}) {
                        $output.= "$indent// Test: $test\n";
                        foreach my $purpose (@SEQUENCE) {
                            my $text= $test_translations{$scanner}{$test}{$purpose}{$lang};
                            my $prepare= $PREPARE{$purpose};
                            update_percent(\$done,$count);
                            if( $prepare ){
                                $text= $prepare->($mw, $text, $test, $purpose, $lang);
                            }
                            my $suffix= uc $purpose;
                            my $fillstring= ' ' x ($fill - length $suffix);
                            $output.= qq:$indent'${test}_$suffix'$fillstring => "$text",\n:;
                        }
                        $output.= "\n";
                    }
                    $output.= "$indent// Result texts follow\n";
                }
                # Data structure is
                # translations {scanner} -> {textname} -> {language}
                my $maxlen= maxlen (keys %{$translations{$scanner}});
                foreach my $textname (sort keys %{$translations{$scanner}}) {
                    next if $textname eq $SCANNER_NAME;
                    my $text= $translations{$scanner}{$textname}{$lang};
                    update_percent(\$done,$count);
                    if( $standard_prepare ){
                        $text= $standard_prepare->($mw, $text, $textname, undef, $lang);
                    }
                    my $fillstring= ' ' x ($maxlen - length $textname);
                    $output.= qq:$indent'$textname'$fillstring => "$text",\n:;
                }
            } else {
                # Print an unmodified template line
                $output.= $_;
            }
        }
        if (not $dryrun) {
            my $outfilename= "$lang_dir/$lang/$scanner.php";
            print "Writing $outfilename\n" if $verbose;
            open my $out, '>:utf8', $outfilename
                or die "Failed to create $outfilename: $!\n";
            print $out $output;
            close $out unless $dryrun;
        }
    }
}

$mw->logout();

sub update_percent {
    my($done, $max)= @_;
    ++$$done;
    printf "\r%5.1f%% ", $$done*100/$max;
}

sub maxlen {
    my $fill= 0;
    foreach ( @_ ) {
        my $l= length $_;
        $fill= $l if $l > $fill;
    }
    return $fill;
}

sub read_text {
    my($path)= @_;
    return "Missing $path" unless -d $path;
    return "Can't read $path" unless -r $path;
    my $result;
    foreach my $file (glob("$path/??$EXT")) {
        my $lang= lc basename $file, $EXT;
        ++$LANGUAGES{$lang};
        $result||= {};
        open my $in, '<:utf8', $file
            or return "Can't read $file";
        $result->{$lang}= do { local $/; <$in>; };
        close $in;
        for ($result->{$lang}) {
            s/[\012\015]+$//s;
            s/[ \t]+$//gm;
        }
    }
    return $result || "No translations in $path";
}

sub parse_wiki {
    my($mw, $text, $textname, $purpose, $lang)= @_;
    if ($verbose) {
        if ($purpose) {
            print "Parsing $textname, $purpose, $lang\n";
        } else {
            print "Parsing $textname, $lang\n";
        }
    }
    my $result= $mw->api({
        action => 'parse',
        format => 'json',
        title => 'none',
        text => $text,
        prop => 'text|links|externallinks',
        disablelimitreport => 'true',
    });
    if( not $result ) {
        die $mw->{error}->{details}. ' ('. $mw->{error}->{code} . ')';
    }
    local($_)= $result->{parse}->{text}->{'*'};
    foreach my $link (@{$result->{parse}->{links}}) {
        my $linktext= quotemeta $link->{'*'};
        if (not exists $link->{exists}) {
            warn "Missing link: $linktext in $textname, $purpose, $lang.\n";
        }
        s#(<a\b[^>]+\b)(href=")/wiki(/[^>"]+"[^>]+\btitle="$linktext")#"$1target=\x22$WIKI_LINK\x22 $2".$settings->{WIKI}.$3#ge;
    }
    foreach my $link (@{$result->{parse}->{externallinks}}) {
        my $linktext= quotemeta $link;
        s#(<a\b[^>]*href="$linktext"[^>]*>)#replace_target($1, $WIKI_EXTERN)#ge;
    }
    s/\\/\\\\/sg;
    s/\n/ /sg;
    s/\r//sg;
    s/"/\\"/sg;
    s/\s+$//s;
    return $_;
}

sub oneline_wiki {
    local($_)= parse_wiki(@_);
    s#</?p>##sg;
    s/&#160;/ /sg;
    s/\s+$//s;
    return $_;
}

sub oneline {
    my($mw, $text, $textname, $purpose)= @_;
    local($_)= $text;
    s/[\r\n]+/ /sg;
    s/&#160;/ /sg;
    s/\s+$//s;
    return $_;
}

sub wikilink {
    my($mw, $text, $textname, $purpose, $lang)= @_;
    print "Lookup  $textname, $purpose, $lang\n" if $verbose;
    my $pagename= $text."/".uc($lang);
    my $page= my $ref = eval {
        $mw->get_page( { title => $pagename } );
    };
    if ($@) {
        warn "Error   $@\n";
        warn "Page    $pagename\n";
        warn "Check   $textname, $purpose, $lang\n" unless $verbose;
    }    
    return $settings->{WIKI}."/".$pagename;
}

sub replace_target {
    my($a, $target)= @_;
    $a=~ s/(?<=\btarget=)(["'']).*?\1/$1$target$1/g;
    return $a;
}
