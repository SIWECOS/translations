#!/usr/bin/perl
=head1 NAME

dir2lang - Convert SIWECOS translations to be used by the application

=head1 SYNOPSIS

B<dir2lang> [B<-v>] [B<--dryrun>]

B<dir2wiki> B<--help>|B<--man>

=head1 Description

dir2lang will take all SIWECOS translations found and copy them into PHP files.

=cut
use strict;
use warnings;
use FindBin qw($Bin $Script);
use Getopt::Long qw(:config no_ignore_case);
use Pod::Usage;
use lib "$Bin/lib";
use MediaWiki::API;
use Config::Simplest;
use File::Basename;
use utf8;

my $EXT='.wiki';

binmode(STDOUT, ":utf8");
my $settings= get_config("$Bin/wiki.conf", qw(WIKI API));
my $config= get_config("$Bin/siwecos.conf");

=head1 options

=over 4

=cut

my $dryrun = 0;
=item B<--dryrun>

=item B<-d>

Just test the translations.

=cut

my $test = '';
=item B<--test> DIRNAME

=item B<-t> DIRNAME

Like B<--dryrun> but create the files in DIRNAME.

=cut

my $verbose= 0;

=item B<-v>

Verbose output.

=cut

help() unless GetOptions(
    'v+'         => \$verbose,
    'dryrun'     => \$dryrun,
    'test=s'     => \$test,
    'h|help'     => \&help,
    'm|man'      => \&man,
);

=item B<--help>

short help page

=item B<--man>

show man page

=back

=cut

sub help { pod2usage(-verbose=>1); }
sub man  { pod2usage(-verbose=>2); }

# Location and names of some directories / files
# $Bin = absolute path of this script
# $Script = filename of this script
my $TRANSLATIONS= "$Bin/texts";
my $LANGUAGE_DIR=  $config->{LANGUAGE_DIR}       || "$Bin/lang";
my $WIKI_LINK=     $config->{TARGET_WIKI_LINK}   || "siwecos_wiki";
my $WIKI_EXTERN=   $config->{TARGET_EXTERN_LINK} || "siwecos_extern";
my $TEMPLATEFILE= "$Bin/$Script.txt";

# Expected purposes
my $CATEGORY     = 'Category';
my $DESCRIPTION  = 'Description';
my $HEADLINE     = 'Headline';
my $LINK         = 'Link';
my $ERROR_TEXT   = 'Negative';
my $SUCCESS_TEXT = 'Positive';
my $TIPP         = 'Solution_Tips';

my %PREPARE = (
    $CATEGORY     => \&oneline,
    $DESCRIPTION  => \&parse_wiki,
    $HEADLINE     => \&oneline_wiki,
    $LINK         => \&wikilink,
    $ERROR_TEXT   => \&oneline_wiki,
    $SUCCESS_TEXT => \&oneline_wiki,
    $TIPP         => \&parse_wiki,
);
my @PURPOSES= sort keys %PREPARE;
# Prepare some output stuff
# Sequence of textnames in output
my @SEQUENCE = (
    $HEADLINE,
    $SUCCESS_TEXT,
    $ERROR_TEXT,
    $DESCRIPTION,
    $TIPP,
    $LINK,
);
my $fill= maxlen( @SEQUENCE);   # number of spaces to use to align values vertically

# First prepare the template
open my $template, '<', $TEMPLATEFILE
    or die "Cannot read template $TEMPLATEFILE: $!\n";
my @template= <$template>;
close $template;

die "Cannot access directory $TRANSLATIONS\n"
    unless -x $TRANSLATIONS and -r $TRANSLATIONS;

my $lang_dir= $test || $LANGUAGE_DIR;
if ( not -d $lang_dir ) {
    mkdir $lang_dir
        or die "Can't create $lang_dir: $!\n";
}
die "Can't write to $lang_dir.\n"
    unless -w $lang_dir;

my %LANGUAGES;
my %test_translations;
my %translations;
my $warning;
foreach my $dir (glob("$TRANSLATIONS/*")) {
    my $scanner= basename $dir;
    print "$scanner\n" if $verbose;
    foreach my $dir (glob("$dir/*")) {
        my $test= basename $dir;
        print "  $test\n" if $verbose;
        # Special cases _RESULTS an _SCANNER_NAME
        if ($test=~ /^_/) {
            #
            # _SCANNER_NAME
            #
            if ($test eq '_SCANNER_NAME') {
                my $text= read_text($dir);
                if (ref $text) {
                    $translations{$scanner}{SCANNER_NAME}= $text;
                } else {
                    ++$warning;
                    warn "$text\n";
                }
            #
            # _RESULTS
            #
            } else {
                foreach my $dir (glob("$dir/*")) {
                    my $textname= basename $dir;
                    my $text= read_text($dir);
                    if (ref $text) {
                        $translations{$scanner}{$textname}= $text;
                    } else {
                        ++$warning;
                        warn "$text\n";
                    }
                }
            }
        } else {
            #
            # TESTS
            #
            while (my($purpose, $prepare)= each %PREPARE) {
                my $text= read_text("$dir/$purpose");
                if (ref $text) {
                    $test_translations{$scanner}{$test}{$purpose}= $text;
                } else {
                    ++$warning;
                    warn "$text\n";
                }
            }
        }
    }
}
my @LANGUAGES= sort keys %LANGUAGES;

die "Too many errors.\n" if $warning;

# Check missing translations
my @scanners= sort keys %test_translations, keys %translations;
foreach my $scanner (@scanners) {
    # Data structure is
    # test_translations {scanner} -> {test} -> {purpose} -> {language}
    foreach my $test (sort keys %{$test_translations{$scanner}}) {
        foreach my $purpose (@PURPOSES) {
            foreach my $lang (@LANGUAGES) {
                next if exists $test_translations{$scanner}{$test}{$purpose}{$lang};
                ++$warning;
                warn "No $lang translation for $scanner/$test/$purpose\n";
            }
        }
    }
    # Data structure is
    # translations {scanner} -> {textname} -> {language}
    foreach my $textname (sort keys %{$translations{$scanner}}) {
        foreach my $lang (@LANGUAGES) {
            next if exists $translations{$scanner}{$textname}{$lang};
            ++$warning;
            if ($textname eq "SCANNER_NAME") {
                warn "No $lang translation for $scanner/_$textname\n";
            } else {
                warn "No $lang translation for $scanner/_RESULTS/$textname\n";
            }
        }
    }
}

die "Too many errors.\n" if $warning;

# We need to use the wiki now
my $mw = MediaWiki::API->new({
    api_url => $settings->{API},
});

my $standard_prepare= $PREPARE{$HEADLINE};
foreach my $scanner (@scanners) {
    foreach my $lang (@LANGUAGES) {
        my $output= '';
        # go through the template, line by line
        foreach (@template) {
            # Until the placeholder /* DATA HERE */ is found
            if( m#^(\s*)/\*\s*DATA\s*HERE\s*\*/\s*#)  {
                # Remember the indent
                my $indent= $1;
                # SCANNER_NAME COMES FIRST!
                my $textname= 'SCANNER_NAME';
                my $text= $translations{$scanner}{$textname}{$lang};
                if (defined $text) {
                    $output.= "$indent// These are the $lang texts for\n";
                    if( $standard_prepare ){
                        $text= $standard_prepare->($mw, $text, $textname, './.', $lang);
                    }
                    $output.= qq:$indent'$textname' => "$text",\n\n:;
                    # Data structure is
                    # test_translations {scanner} -> {test} -> {purpose} -> {language}
                    foreach my $test (sort keys %{$test_translations{$scanner}}) {
                        $output.= "$indent// Test: $test\n";
                        foreach my $purpose (@SEQUENCE) {
                            my $text= $test_translations{$scanner}{$test}{$purpose}{$lang};
                            my $prepare= $PREPARE{$purpose};
                            if( $prepare ){
                                $text= $prepare->($mw, $text, $test, $purpose, $lang);
                            }
                            my $suffix= uc $purpose;
                            my $fillstring= ' ' x ($fill - length $suffix);
                            $output.= qq:$indent'${test}_$suffix'$fillstring => "$text",\n:;
                        }
                        $output.= "\n";
                    }
                    $output.= "$indent// Result texts follow\n";
                }
                # Data structure is
                # translations {scanner} -> {textname} -> {language}
                my $maxlen= maxlen (keys %{$translations{$scanner}});
                foreach my $textname (sort keys %{$translations{$scanner}}) {
                    next if $textname eq 'SCANNER_NAME';
                    my $text= $translations{$scanner}{$textname}{$lang};
                    if( $standard_prepare ){
                        $text= $standard_prepare->($mw, $text, $textname, undef, $lang);
                    }
                    my $fillstring= ' ' x ($maxlen - length $textname);
                    $output.= qq:$indent'$textname'$fillstring => "$text",\n:;
                }
            } else {
                # Print an unmodified template line
                $output.= $_;
            }
        }
        if (not $dryrun) {
            open my $out, '>:utf8', "$lang_dir/$lang/$scanner.php"
                or die "Failed to create $lang_dir/$lang/$scanner.php: $!\n";
            print $out $output;
            close $out unless $dryrun;
        }
    }
}

sub maxlen {
    my $fill= 0;
    foreach ( @_ ) {
        my $l= length $_;
        $fill= $l if $l > $fill;
    }
    return $fill;
}

sub read_text {
    my($path)= @_;
    return "Missing $path" unless -d $path;
    return "Can't read $path" unless -r $path;
    my $result;
    foreach my $file (glob("$path/??$EXT")) {
        my $lang= lc basename $file, $EXT;
        ++$LANGUAGES{$lang};
        $result||= {};
        open my $in, '<:utf8', $file
            or return "Can't read $file";
        $result->{$lang}= do { local $/; <$in>; };
        close $in;
        for ($result->{$lang}) {
            s/[\012\015]+$//s;
            s/[ \t]+$//gm;
        }
    }
    return $result || "No translations in $path";
}

sub parse_wiki {
    my($mw, $text, $textname, $purpose, $lang)= @_;
    if ($verbose) {
        if ($purpose) {
            print "Parsing $textname, $purpose, $lang\n";
        } else {
            print "Parsing $textname, $lang\n";
        }
    }
    my $result= $mw->api({
        action => 'parse',
        format => 'json',
        title => 'none',
        text => $text,
        prop => 'text|links|externallinks',
        disablelimitreport => 'true',
    });
    if( not $result ) {
        die $mw->{error}->{details}. ' ('. $mw->{error}->{code} . ')';
    }
    local($_)= $result->{parse}->{text}->{'*'};
    foreach my $link (@{$result->{parse}->{links}}) {
        my $linktext= quotemeta $link->{'*'};
        if (not exists $link->{exists}) {
            warn "Missing link: $linktext in $textname, $purpose, $lang.\n";
        }
        s#(<a\b[^>]+\b)(href=")/wiki(/[^>"]+"[^>]+\btitle="$linktext")#"$1target=\x22$WIKI_LINK\x22 $2".$settings->{WIKI}.$3#ge;
    }
    foreach my $link (@{$result->{parse}->{externallinks}}) {
        my $linktext= quotemeta $link;
        s#(<a\b[^>]*href="$linktext"[^>]*>)#replace_target($1, $WIKI_EXTERN)#ge;
    }
    s/\\/\\\\/sg;
    s/\n/ /sg;
    s/\r//sg;
    s/"/\\"/sg;
    s/\s+$//s;
    return $_;
}

sub oneline_wiki {
    local($_)= parse_wiki(@_);
    s#</?p>##sg;
    s/&#160;/ /sg;
    s/\s+$//s;
    return $_;
}

sub oneline {
    my($mw, $text, $textname, $purpose)= @_;
    local($_)= $text;
    s/[\r\n]+/ /sg;
    s/&#160;/ /sg;
    s/\s+$//s;
    return $_;
}

sub wikilink {
    my($mw, $text, $textname, $purpose, $lang)= @_;
    return $settings->{WIKI}."/$text/".uc($lang);
}

sub replace_target {
    my($a, $target)= @_;
    $a=~ s/(?<=\btarget=)(["'']).*?\1/$1$target$1/g;
    return $a;
}

__END__
# get all translation filenames
# Directory structure is $TRANSLATIONS / placeholder / purpose / language $EXT
# Also collect categories
my $language_data= {};
my $categories= {};
my %category_missing;
my %category_found;
my %translations_found;
my %translations_language;
my $todo;
foreach( glob("$TRANSLATIONS/*/*/*$EXT") ) {
    # Split pathname into parts
    my ($placeholder, $purpose, $lang)= (split m#/#, $_)[-3..-1];
    # remove filename extension
    $lang=~ s#\.[^./]+$##;
    next unless $purpose eq 'Category'
        or exists $SUFFIX{$purpose};
    # Read the file
    if( open my $trans, '<', $_ ) {
        binmode($trans, ":utf8");
        # into our data structures
        my $text= do {
            local $/;
            <$trans>;
        };
        for ($text) {
            chomp;
            s/[ \t]+$//gm;
        }
        close $trans;
        # If a category is set, setup the category data structure
        if( $purpose eq "Category" ) {
            $language_data->{$lang}->{$placeholder} ||= {};
            $text=~ /(\w+[\w -]*)\b/; # Just first category
            $categories->{$lang}->{$1}->{$placeholder} = $language_data->{$lang}->{$placeholder};
            ++$category_found{$lang}->{$placeholder};
        } else {
            $language_data->{$lang}->{$placeholder}->{$purpose}= $text;
            ++$category_missing{$lang}->{$placeholder};
            my $text= "$purpose for $placeholder";
            ++$translations_found{$text};
            ++$translations_language{$lang}->{$text};
            ++$todo;
        }
    }
    else {
        warn $CLEARLINE."Can't read $_: $!";
    }
}
# All translations are in memory now

# debug my $count;
# debug while (my($lang, $v) = each %$categories) {
# debug     while (my($cat, $v) = each %$v) {
# debug         while (my($pl, $v) = each %$v) {
# debug             while (my($pu, $v) = each %$v) {
# debug                 ++$count;
# debug             }
# debug         }
# debug     }
# debug }
# debug die $count,"\t",$todo;

my $IS_WINDOS= $ENV{OS} and $ENV{OS}=~ /windows/i;

my $lang_dir = $LANGUAGE_DIR;
if ($dryrun or not $IS_WINDOS) {
    $lang_dir= tempdir( DIR => $Bin, CLEANUP => 1 )
        or die "Failed to create a temporary directory in $Bin: $!\n";
} elsif ($test and $IS_WINDOS) {
    $lang_dir= $test;
    if ( ! -d $test ) {
        mkdir $test
            or die "Failed to create test-directory $test: $!\n";
    }
}

# We need to use the wiki
my $mw = MediaWiki::API->new({
    api_url => $settings->{API},
});

my $progress=  do {
    if ($IS_WINDOS) {
        SimpleProgressBar->new(
            max => $todo,
            dumb => 1,
        );
    } else {
        SimpleProgressBar->new(
            max => $todo,
            rotator => ($todo > 100) ? "\x{2838}\x{28b0}\x{28e0}\x{28c4}\x{2846}\x{2807}\x{280b}\x{2819}" : undef,
            cursor => 1,
            fill => "\x{28ff}",
            empty => "\x{2880}",
        );
    }
};
my $done;
# Go through each language
foreach my $language (keys %$categories) {
    delete @{$category_missing{$language}}{ keys %{$category_found{$language}} };
    foreach my $placeholder (sort keys %{$category_missing{$language}}) {
        warn $CLEARLINE."Missing $language category for $placeholder\n";
        $categories->{$language}->{"* NO CATEGORY *"}->{$placeholder}=$language_data->{$language}->{$placeholder};
    }
    foreach (sort keys %translations_found) {
        next if exists $translations_language{$language}->{$_};
        warn $CLEARLINE."Missing $language $_\n";
    }
    my $cats= $categories->{$language};
    # Create a directory for the language
    if (! -d "$lang_dir/$language" ) {
        mkdir "$lang_dir/$language"
            or die $CLEARLINE."Failed to create directory $lang_dir/$language: $!\n";
    }
    # Create the language file for the current language
    open my $out, '>', "$lang_dir/$language/$LANGUAGE_FILE"
        or die $CLEARLINE."Failed to create $lang_dir/$language/$LANGUAGE_FILE: $!\n";
    binmode($out, ':utf8');
    # Work through the template lines
    foreach (@template) {
        # Until the placeholder /* DATA HERE */ is found
		if( m#^(\s*)/\*\s*DATA\s*HERE\s*\*/\s*#)  {
            # Remember the indent
            my $indent= $1;
            # Go through each category in alphabetical order
            foreach my $category (sort keys %$cats) {
                # Print the category as comment
                print $out "$indent//\n$indent// Category: $category\n";
                my $placeholders= $cats->{$category};
                # Go through each placeholder in alphabetical order
                foreach my $placeholder (sort keys %$placeholders){
                    # Print the placeholder as a comment
                    print $out "$indent//\n$indent// $placeholder\n";
                    my $p= $placeholders->{$placeholder};
                    # Go through each of the purposes we want to print
                    # They are defined at the top under "# Prepare some output stuff"
                    foreach my $purpose (@SEQUENCE) {
                        my $text= $p->{$purpose};
                        # Skip this entry if there is nothing to be printed
                        next unless defined $text;
                        $progress->update($done++);
                        my $prepare= $PREPARE{$purpose};
                        if( $prepare ){
                            $text= $prepare->($mw, $text, $placeholder, $purpose, $language);
                        }
                        my $suffix= $SUFFIX{$purpose};
                        my $fillstring= ' ' x ($fill - length $suffix);
                        print $out "$indent'$placeholder$suffix'$fillstring => \"$text\",\n";
                    }
                }
            }
		} else {
            # Print an unmodified template line
    		print $out $_;
		}
	}
}
$progress->update($done);
print $/;

if ($dryrun) {
    # remove newly created language files
    rmtree($lang_dir);
} elsif (not $IS_WINDOS) {
    # remove existing language files
    $LANGUAGE_DIR = $test if $test;
    if ( -e $LANGUAGE_DIR ) {
        rmtree($LANGUAGE_DIR);
    }
    # rename the new language file directory
    rename $lang_dir, $LANGUAGE_DIR
        or die "Failed to create directory $LANGUAGE_DIR: $!\n";
}

